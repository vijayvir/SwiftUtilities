//
//  MoveToCanvas.js
//  ProjectName
//
//  Created by AuthorName on 09/09/23.
//  Copyright Â© 2023 CompanyName. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



//// APIs you can use in your code:
//
// Available methods for drawing into <canvas> elements:
//    MoveToCanvas.drawCanvas1(canvas, targetFrame*, resizing*)
//
// NOTE: 'canvas' parameter can be either a <canvas> element object, or the id of a <canvas> element in your document.
//
// NOTE: Parameters marked with the '*' symbol are optional
//
// NOTE: Possible arguments for 'resizing' parameter in drawing methods are:
//   'aspectfit': The content is proportionally resized to fit into the target rectangle.
//   'aspectfill': The content is proportionally resized to completely fill the target rectangle.
//   'stretch': The content is stretched to match the entire target rectangle.
//   'center': The content is centered in the target rectangle, but it is NOT resized.
//
// Available Utilities:
//    MoveToCanvas.clearCanvas(canvas)
//    MoveToCanvas.makeRect(x, y, width, height)


//// Create StyleKit Object
var MoveToCanvas = {};
(function() {

    //// Drawing Methods

    function drawCanvas1(canvas, targetFrame, resizing) {
        //// General Declarations
        canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
        var context = canvas.getContext('2d');
        
        //// Resize to Target Frame
        context.save();
        var resizedFrame = applyResizingBehavior(resizing, makeRect(0, 0, 240, 240), targetFrame);
        context.translate(resizedFrame.x, resizedFrame.y);
        context.scale(resizedFrame.w / 240, resizedFrame.h / 240);


        //// Bezier Drawing
        context.beginPath();
        context.moveTo(184.5, 76.5);
        context.lineTo(49.5, 76.5);
        context.lineTo(35.5, 132.5);
        context.lineTo(35.5, 161.5);
        context.lineTo(204.5, 161.5);
        context.lineTo(184.5, 76.5);
        context.closePath();
        context.fillStyle = 'rgb(128, 128, 128)';
        context.fill();
        context.strokeStyle = 'rgb(0, 0, 0)';
        context.lineWidth = 1;
        context.stroke();
        
        context.restore();

    }

    //// Infrastructure

    function clearCanvas(canvas) {
        canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
    }

    // Possible arguments for 'resizing' parameter are:
    //   'aspectfit': The content is proportionally resized to fit into the target rectangle.
    //   'aspectfill': The content is proportionally resized to completely fill the target rectangle.
    //   'stretch': The content is stretched to match the entire target rectangle.
    //   'center': The content is centered in the target rectangle, but it is NOT resized.
    function applyResizingBehavior(resizing, rect, targetRect) {
        if (targetRect === undefined || equalRects(rect, targetRect) || equalRects(targetRect, makeRect(0, 0, 0, 0))) {
            return rect;
        }

        var scales = makeSize(0, 0);
        scales.w = Math.abs(targetRect.w / rect.w);
        scales.h = Math.abs(targetRect.h / rect.h);

        switch (resizing) {
            case 'aspectfit': {
                scales.w = Math.min(scales.w, scales.h);
                scales.h = scales.w;
                break;
            }
            case 'aspectfill': {
                scales.w = Math.max(scales.w, scales.h);
                scales.h = scales.w;
                break;
            }
            case 'stretch':
            case undefined:
                break;
            case 'center': {
                scales.w = 1;
                scales.h = 1;
                break;
            }
            default:
                throw 'Unknown resizing behavior "' + resizing + '". Use "aspectfit", "aspectfill", "stretch" or "center" as resizing behavior.';
        }

        var result = makeRect(Math.min(rect.x, rect.x + rect.w), Math.min(rect.y, rect.y + rect.h), Math.abs(rect.w), Math.abs(rect.h));
        result.w *= scales.w;
        result.h *= scales.h;
        result.x = targetRect.x + (targetRect.w - result.w) / 2;
        result.y = targetRect.y + (targetRect.h - result.h) / 2;
        return result;
    }

    function makeRect(x, y, w, h) {
        return { x: x, y: y, w: w, h: h };
    }

    function equalRects(r1, r2) {
        return r1.x === r2.x && r1.y === r2.y && r1.w == r2.w && r1.h === r2.h;
    }

    function makeSize(w, h) {
        return { w: w, h: h };
    }

    //// Public Interface

    // Drawing Methods
    MoveToCanvas.drawCanvas1 = drawCanvas1;

    // Utilities
    MoveToCanvas.clearCanvas = clearCanvas;
    MoveToCanvas.makeRect = makeRect;

})();
