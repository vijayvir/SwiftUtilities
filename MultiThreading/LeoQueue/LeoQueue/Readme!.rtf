{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red255\green255\blue255;\red44\green50\blue53;
\red239\green239\blue239;\red152\green224\blue36;\red29\green30\blue26;\red246\green246\blue239;\red224\green213\blue97;
\red111\green127\blue145;}
{\*\expandedcolortbl;;\cssrgb\c20000\c20000\c20000;\cssrgb\c100000\c100000\c100000;\cssrgb\c22745\c25490\c27059;
\cssrgb\c94902\c94902\c94902;\cssrgb\c65098\c88627\c18039;\cssrgb\c15294\c15686\c13333;\cssrgb\c97255\c97255\c94902;\cssrgb\c90196\c85882\c45490;
\cssrgb\c50980\c57255\c63529;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\b\fs60 \cf2 \cb3 \expnd0\expndtw0\kerning0
Asynchronous vs synchronous tasks\cb1 \
\pard\pardeftab720\partightenfactor0

\f1\b0\fs38 \cf4 \cb3 A 
\f2\fs32\fsmilli16150 \cb5 DispatchQueue
\f1\fs38 \cb3  task can be run synchronously or asynchronously. The main difference occurs when you create the task.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Synchronously starting a task will block the calling thread until the task is finished\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Asynchronously starting a task will directly return on the calling thread without blocking\cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 Say you would add a task to the queue from the main thread, you want to prevent yourself from using the sync method for long-running tasks. This would block the main thread and makes your UI unresponsive.\cb1 \
\pard\pardeftab720\partightenfactor0

\f0\b\fs60 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 Difference between Global dispatch Queue and Concurrent custom queue. \
 
\fs46 \cb1 \
\pard\pardeftab720\partightenfactor0

\f1\b0\fs38 \cf4 \cb3 It\'92s best practice to make use of the global concurrent dispatch queues. This prevents you from creating too many private concurrent queues. Apart from this, you should still be conscious of executing long-blocking tasks.\cb1 \
\cb3 You can make use of the global concurrent queue as follows:\
\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs26\fsmilli13300 \cf6 \cb7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 global\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ().async \{\
    \cf10 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 /// Concurrently execute a task using the global concurrent queue. Also known as the background queue.\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs38 \cf4 \cb3 \shad0 \
Concurrent dispatch queue \
It will throw back to calling queue. for eg: if it call from main queue, the concurrent queue work in private queue, when the operations are performed it put it to main queue }